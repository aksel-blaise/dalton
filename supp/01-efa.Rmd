# Elliptical Fourier Analysis

Prior to running the landmark 3D geometric morphometric (3DGM) analysis, an elliptical Fourier analysis (EFA) was conducted to identify differences in the plan view of Dalton projectile points. These data have utility in developing the subsequent 3D landmarking protocol (LM3d3) used for the 3DGM analysis.

The 2D images used in the EFA were exported as screen captures from _Geomagic Design X_, and are oriented using the same (exact) alignment as the 3D dataset. Each image was masked in Photoshop to render the binary (black/white) image used for this preliminary analysis.

## Load packages + data

```{r load.packages.efa, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# load packages
library(here)
library(tidyverse)
library(wesanderson)
library(Momocs)

# read images + attribute data
jpg.list <- list.files(here("/jpeg"), full.names = TRUE)
att.data <- read.csv("qdata.csv", header = TRUE, as.is = TRUE)

# attributes to factors
att.data$heart.out <- as.factor(att.data$heart.out)
att.data$heart.out <- as.factor(att.data$heart.out)
att.data$heart.reg <- as.factor(att.data$heart.reg)
att.data$bev <- as.factor(att.data$bev)
att.data$bev.type <- as.factor(att.data$bev.type)
```

## Generate outlines

```{r outlines + attribues, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# generate outlines
outlines <- jpg.list %>%
  import_jpg()

# add attributes
data.out <- Out(outlines, 
         fac = att.data)

# center, scale, align, and rotate specimens
norm.outlines <- data.out %>% 
  coo_scale() %>%
  coo_rotate() %>% 
  coo_align() %>%
  coo_center()
```

## Pile and mosaics

```{r stack.panel, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# outline pile
pile(norm.outlines)

# mosaics
# in/out of heartland
mosaic(norm.outlines, 
       ~heart.out, 
       asp = 1, 
       palette = pal_qual_Dark2)
# heartland regions (heartland, interior, and northern periphery)
mosaic(norm.outlines, 
       ~heart.reg, 
       asp = 1, 
       palette = pal_qual_Dark2)
# beveled or not
mosaic(norm.outlines, 
       ~bev, 
       asp = 1, 
       palette = pal_qual_Dark2)
# bevel type
mosaic(norm.outlines, 
       ~bev.type, 
       asp = 1, 
       palette = pal_qual_Dark2)
```

## Calibrate harmonic + EFA

```{r cal.harm, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# calibrate how many harmonics needed
calibrate_harmonicpower_efourier(norm.outlines, nb.h = 20)

# 10 harmonics capture 99 percent of variation
calibrate_reconstructions_efourier(norm.outlines, range = 1:10)

# generate efa outlines with 10 harmonics
efa.outlines <- efourier(norm.outlines, nb.h = 10, norm = TRUE)
```

## Principal Components Analysis

```{r pca.plot, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# use efa.outlines for pca
pca.outlines <- PCA(efa.outlines)

# pca 
scree_plot(pca.outlines)

# plot pca
# heartland in/out
plot_PCA(pca.outlines, 
         morphospace_position = "range", 
         ~heart.out, zoom = 1.25, 
         palette = pal_qual_Dark2)
# heartland region
plot_PCA(pca.outlines, 
         morphospace_position = "range", 
         ~heart.reg, zoom = 1.25, 
         palette = pal_qual_Dark2)
# beveled or not
plot_PCA(pca.outlines, 
         morphospace_position = "range", 
         ~bev, zoom = 1.25, 
         palette = pal_qual_Dark2)
# bevel type
plot_PCA(pca.outlines, 
         morphospace_position = "range", 
         ~bev.type, zoom = 1.25, palette = pal_qual_Dark2)

# contribution of each pc
boxplot(pca.outlines, 
        ~heart.out, 
        nax = 1:5, 
        palette = pal_qual_Dark2)
boxplot(pca.outlines, 
        ~heart.reg, 
        nax = 1:5, 
        palette = pal_qual_Dark2)
boxplot(pca.outlines, 
        ~bev, 
        nax = 1:5, 
        palette = pal_qual_Dark2)
boxplot(pca.outlines, 
        ~bev.type, 
        nax = 1:5, 
        palette = pal_qual_Dark2)

# mean shape + 2sd for the first 10 pcs
PCcontrib(pca.outlines, 
          nax = 1:5)
```

## MANOVA + MANOVA_PW

```{r manova, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# manova + manova_pw
# do shapes differ in/out of heartland?
MANOVA(pca.outlines, 'heart.out')
# do shapes differ between heartland regions?
MANOVA(pca.outlines, 'heart.reg')
# which?
MANOVA_PW(pca.outlines, 'heart.reg')
# do shapes differ if beveled?
MANOVA(pca.outlines, 'bev')
# do shapes differ by bevel type?
MANOVA(pca.outlines, 'bev.type')
# which?
MANOVA_PW(pca.outlines, 'bev.type')
```

## Mean shapes

```{r ms1, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="Mean shapes for in (H) and out (N) of the heartland."}
# mean shapes
ms.1 <- MSHAPES(efa.outlines, 
                ~heart.out)
plot_MSHAPES(ms.1, size = 0.75)
```

```{r ms2, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="Mean shapes for heartland (H), interior (I), and northern periphery (P)."}
# mean shapes
ms.2 <- MSHAPES(efa.outlines, 
                ~heart.reg)
plot_MSHAPES(ms.2, size = 0.75)
```

```{r ms3, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="Mean shapes for beveled (y), and not beveled (n)."}
# mean shapes
ms.3 <- MSHAPES(efa.outlines, 
                ~bev)
plot_MSHAPES(ms.3, size = 0.75)
```

```{r ms4, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="Mean shapes for alternate, unifacial.bimarginal, and no.bevel."}
# mean shapes
ms.4 <- MSHAPES(efa.outlines, 
                ~bev.type)
plot_MSHAPES(ms.4, size = 0.75)
```
