# Analysis of Dalton point morphology

## Load packages + data

```{r load.data, echo = TRUE}
# load packages

# devtools::install_github("geomorphR/geomorph", ref = "Stable", build_vignettes = TRUE)
library(geomorph)
library(wesanderson)

# setwd
setwd(getwd())

# read GM data
source('readmulti.csv.R')

# read .csv files
setwd("./data")
filelist <- list.files(pattern = ".csv")
coords <- readmulti.csv(filelist)
setwd("../")

# read qualitative data
qdata <- read.csv("qdata.csv", header = TRUE, row.names = 1)
qdata <- qdata[match(dimnames(coords)[[3]],rownames(qdata)),]

# print qdata
knitr::kable(qdata, align = "cccc", caption = "Attributes included in qdata.")
```

## Generalized Procrustes Analysis

Landmark data were aligned to a global coordinate system [@RN11622;@RN11623;@RN11563], achieved through generalized Procrustes superimposition [@RN478] performed in R 4.0.2 [@R] using the `geomorph` library v. 3.3.1 [@RN11530;@RN1774]. Procrustes superimposition translates, scales, and rotates the coordinate data to allow for comparisons among objects [@RN11564;@RN478]. The `geomorph` package uses a partial Procrustes superimposition that projects the aligned specimens into tangent space subsequent to alignment in preparation for the use of multivariate methods that assume linear space [@RN1646;@RN11563]. 

```{r gpa, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# gpa
Y.gpa <- gpagen(coords, PrinAxes = TRUE, ProcD = TRUE, 
                Proj = TRUE, print.progress = FALSE)

# output + consensus configuration coords
Y.gpa

# geomorph data frame
gdf <- geomorph.data.frame(shape = Y.gpa$coords, size = Y.gpa$Csize, 
                           heart = qdata$heart.out, hreg = qdata$heart.reg)
```

```{r consensus, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="2D plot of 3D consensus configuration."}
# plot consensus configuration
par(mfrow=c(1, 3))
plot(Y.gpa$consensus[,c("Y", "X")], pch=20)
plot(Y.gpa$consensus[,c("Z", "X")], pch=20)
plot(Y.gpa$consensus[,c("Z", "Y")], pch=20)
```

```{r 3d.gpa, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="Results of generalized Procrustes analysis."}
# render 3d gpa plot
#plot(Y.gpa)

# gpa plot
# knitr::include_graphics('images/gpa3d.png')
```

## Boxplots by centroid size

```{r box.attr, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# attributes for boxplots
csz <- Y.gpa$Csize # centroid size
heart <- qdata$heart.out # heartland in/out
hreg <- qdata$heart.reg # heartland region
bev.1 <- qdata$bev # beveled yes/no
bev.2 <- qdata$bev.type # type of beveling
```

```{r box1, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap = "Boxplot of centroid size by Heartland (in/out)."}
# boxplot of Dalton point centroid size by in/out heartland
b1 <- boxplot(csz~heart,
        names = c("H","N"), # heartland (H), and not heartland (N)
        xlab = "Heartland",
        ylab = "Centroid Size",
        col = wes_palette("Moonrise2"),
        )
b1
```

```{r box2, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap = "Boxplot of centroid size by Heartland region."}
# boxplot of Dalton point centroid size by heartland + regions
b2 <- boxplot(csz~hreg,
        names = c("H","I","P"), # heartland (H), interior (I), and northern periphery (P)
        xlab = "Heartland Region",
        ylab = "Centroid Size",
        col = wes_palette("Moonrise2")
        )
b2
```

```{r box3, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap = "Boxplot of centroid size by beveled."}
# boxplot of Dalton point centroid size by beveled y/n
b3 <- boxplot(csz~bev.1,
        names = c("y","n"), # yes/no
        xlab = "Beveled?",
        ylab = "Centroid Size",
        col = wes_palette("Moonrise2")
        )
b3
```

```{r box4, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap = "Boxplot of centroid size by bevel type."}
# boxplot of Dalton point centroid size by bevel type
b4 <- boxplot(csz~bev.2,
        names = c("alternate","no.bevel","unifacial.bimarginal"), # bevel type/no bevel
        xlab = "Beveled Type",
        ylab = "Centroid Size",
        col = wes_palette("Moonrise2"),
        )
b4
```

## Principal Components Analysis

Principal components analysis [@RN1746] was used to visualise shape variation among the bifaces. The shape changes described by each principal axis are commonly visualized using thin-plate spline warping of a reference 3D mesh [@RN1731;@RN479]. 

```{r pca, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# principal components analysis
pca<-gm.prcomp(Y.gpa$coords)
summary(pca)

# set plot parameters to plot by heartland in (H) and out (N)
pch.gps.heart <- c(15,17)[as.factor(heart)]
col.gps.heart <- wes_palette("Moonrise2")[as.factor(heart)]
col.hull <- c("#798E87","#C27D38")

# plot pca by heartland in (H) and out (N)
pc.plot1 <- plot(pca, 
                 asp = 1,
                 pch = pch.gps.heart,
                 col = col.gps.heart)
                    shapeHulls(pc.plot1, 
                             groups = heart,
                             group.cols = col.hull)
                  
# set plot parameters to plot by heartland + regions
pch.gps.hreg <- c(15,17,18)[as.factor(hreg)]
col.gps.hreg <- wes_palette("Moonrise2")[as.factor(hreg)]
col.hull.2 <- c("#798E87","#CCC591","#C27D38")

# plot pca by heartland + regions
pc.plot2 <- plot(pca, 
                 asp = 1,
                 pch = pch.gps.hreg,
                 col = col.gps.hreg)
                    shapeHulls(pc.plot2, 
                             groups = hreg,
                             group.cols = col.hull.2)
                    
# set plot parameters to plot by beveled y and n
pch.gps.bev.1 <- c(15,17)[as.factor(bev.1)]
col.gps.bev.1 <- wes_palette("Moonrise2")[as.factor(bev.1)]
col.hull.3 <- c("#C27D38","#798E87")

# plot pca by heartland in (H) and out (N)
pc.plot3 <- plot(pca, 
                 asp = 1,
                 pch = pch.gps.bev.1,
                 col = col.gps.bev.1)
                    shapeHulls(pc.plot3, 
                             groups = bev.1,
                             group.cols = col.hull.3)
                    
# set plot parameters to plot by bevel type
pch.gps.bev.2 <- c(15,17,18)[as.factor(bev.2)]
col.gps.bev.2 <- wes_palette("Moonrise2")[as.factor(bev.2)]
col.hull.4 <- c("#CCC591","#C27D38","#798E87")

# plot pca by bevel type
pc.plot4 <- plot(pca, 
                 asp = 1,
                 pch = pch.gps.bev.2,
                 col = col.gps.bev.2)
                    shapeHulls(pc.plot4, 
                             groups = bev.2,
                             group.cols = col.hull.4)
```

## Define models

### Hypothesis 1

```{r def.mod.1, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
## Define models
# size as a function of heart
fit.size.heart <- procD.lm(size ~ heart, 
                           data = gdf, 
                           print.progress = FALSE, 
                           iter = 9999)
# shape as a function of heart
fit.shape.heart <- procD.lm(shape ~ heart, 
                            data = gdf, 
                            print.progress = FALSE, 
                            iter = 9999)
```

### Hypothesis 2

```{r def.mod.2, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
## Define models
# size as a function of hreg
fit.size.hreg <- procD.lm(size ~ hreg, 
                          data = gdf, 
                          print.progress = FALSE, 
                          iter = 9999)


# shape as a function of hreg
fit.shape.hreg <- procD.lm(shape ~ hreg, 
                           data = gdf, 
                           print.progress = FALSE, 
                           iter = 9999)
```

### Hypothesis 3

```{r def.mod.3, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
## Define models
# size as a function of bev.1
fit.size.bev.1 <- procD.lm(size ~ bev.1, 
                          data = gdf, 
                          print.progress = FALSE, 
                          iter = 9999)


# shape as a function of bev.1
fit.shape.bev.1 <- procD.lm(shape ~ bev.1, 
                           data = gdf, 
                           print.progress = FALSE, 
                           iter = 9999)
```

### Hypothesis 4

```{r def.mod.4, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
## Define models
# size as a function of bev.2
fit.size.bev.2 <- procD.lm(size ~ bev.2, 
                          data = gdf, 
                          print.progress = FALSE, 
                          iter = 9999)


# shape as a function of bev.2
fit.shape.bev.2 <- procD.lm(shape ~ bev.2, 
                           data = gdf, 
                           print.progress = FALSE, 
                           iter = 9999)
```

## Test Hypothesis 1

Hypothesis 1 assesses whether there is a difference in morphology for Dalton points found in and out of the heartland.

A residual randomization permutation procedure (RRPP; n = 10,000 permutations) was used for all Procrustes ANOVAs [@RN1655;@RN11775], which has higher statistical power and a greater ability to identify patterns in the data should they be present [@RN1719]. To assess whether shape changes with size (allometry), and differs by group (region), Procrustes ANOVAs [@RN1749] were also run that enlist effect-sizes (zscores) computed as standard deviates of the generated sampling distributions [@RN1756]. 

```{r lm3d3.a1.h1, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="_**Figure 18. Hypothesis 1 considers whether Dalton points discovered in (left) and out (right) of the Heartland differ in morphology.**_"}
knitr::include_graphics('images/dalton-vizhypothesis1.jpg')
```

```{r h1, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# ANOVA: do dalton projectile point sizes differ by heart?
anova(fit.size.heart)

# ANOVA: do dalton projectile point shapes differ by heart?
anova(fit.shape.heart)
```

## Test Hypothesis 2

Hypothesis 2 assesses whether there is a difference in morphology for Dalton points found in the heartland, the interior, and the northern periphery.

A residual randomization permutation procedure (RRPP; n = 10,000 permutations) was used for all Procrustes ANOVAs [@RN1655;@RN11775], which has higher statistical power and a greater ability to identify patterns in the data should they be present [@RN1719]. To assess whether shape changes with size (allometry), and differs by group (region), Procrustes ANOVAs [@RN1749] were also run that enlist effect-sizes (zscores) computed as standard deviates of the generated sampling distributions [@RN1756]. 

```{r lm3d3.a1.h2, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="_**Figure 19. Hypothesis 2 considers whether Dalton points discovered in the heartland (left), interior (center), and northern periphery (right) differ in morphology.**_"}
knitr::include_graphics('images/dalton-vizhypothesis2.jpg')
```

```{r h2, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# ANOVA: does dalton projectile point size differ by hreg?
anova(fit.size.hreg)
# pairwise comparison of LS means = which differ?
sz.hreg <- pairwise(fit.size.hreg, 
                    groups = qdata$heart.reg)
summary(sz.hreg, 
        confidence = 0.95, 
        test.type = "dist")
# pairwise distance between variances = standardization?
summary(sz.hreg, 
        confidence = 0.95, 
        test.type = "var")

# ANOVA: does dalton projectile point shape differ by hreg?
anova(fit.shape.hreg)
# pairwise comparison of LS means = which differ?
sh.hreg <- pairwise(fit.shape.hreg, 
                    groups = qdata$heart.reg)
summary(sz.hreg, 
        confidence = 0.95, 
        test.type = "dist")
# pairwise distance between variances = standardization?
summary(sz.hreg, 
        confidence = 0.95, 
        test.type = "var")
```

## Test Hypothesis 3

Hypothesis 3 assesses whether there is a discernible difference in morphology for Dalton points that are beveled.

A residual randomization permutation procedure (RRPP; n = 10,000 permutations) was used for all Procrustes ANOVAs [@RN1655;@RN11775], which has higher statistical power and a greater ability to identify patterns in the data should they be present [@RN1719]. To assess whether shape changes with size (allometry), and differs by group (region), Procrustes ANOVAs [@RN1749] were also run that enlist effect-sizes (zscores) computed as standard deviates of the generated sampling distributions [@RN1756]. 

```{r lm3d3.a1.h3, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE, fig.cap="_**Figure 20. Hypothesis 3 considers whether beveled Dalton points (left) differ in morphology from those that are not beveled (right).**_"}
knitr::include_graphics('images/dalton-vizhypothesis3.jpg')
```

```{r h3, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# ANOVA: do dalton projectile point sizes differ by beveling?
anova(fit.size.bev.1)

# ANOVA: do dalton projectile point shapes differ by beveling?
anova(fit.shape.bev.1)
```

## Test Hypothesis 4

```{r h4, out.width = "100%", dpi = 300, echo=TRUE, warning=FALSE}
# ANOVA: does dalton projectile point size differ by bev.2?
anova(fit.size.bev.2)
# pairwise comparison of LS means = which differ?
sz.bev.2 <- pairwise(fit.size.bev.2, 
                    groups = qdata$bev.type)
summary(sz.bev.2, 
        confidence = 0.95, 
        test.type = "dist")
# pairwise distance between variances = standardization?
summary(sz.bev.2, 
        confidence = 0.95, 
        test.type = "var")

# ANOVA: does dalton projectile point shape differ by bev.2?
anova(fit.shape.bev.2)
# pairwise comparison of LS means = which differ?
sh.bev.2 <- pairwise(fit.shape.bev.2, 
                    groups = qdata$bev.type)
summary(sz.bev.2, 
        confidence = 0.95, 
        test.type = "dist")
# pairwise distance between variances = standardization?
summary(sz.bev.2, 
        confidence = 0.95, 
        test.type = "var")
```
